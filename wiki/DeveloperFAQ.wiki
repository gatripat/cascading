#summary Answers to common questions

= Developer FAQ =

Also see our evolving [http://www.cascading.org/documentation/cook-book.html Cook Book] on the main site.

=== How do I convert String tuple values to their primitive types for more efficient storage? ===

 Use the `c.o.Identity` class to coerce values to new types. If a tuple value is "1234", you could coerce it to a Integer. For example:
{{{
  pipe = new Each( pipe, new Fields("index_string"), new Identity( new Fields("index"), Integer.class), Fields.ALL );
}}}

=== What do all these constants on the c.t.Fields class mean? ===

 See the javadoc for details. In short, they represent logical groups of fields, so that pipe assemblies don't need to hard code field names if they perform common operations. For example, `Fields.ALL` represents all the fields in the current stream, i.e. a wild card. `Fields.KEYS` represent the grouping fields used by a previous `c.p.Group` pipe.

=== Can I reference tuple values by position instead of by field name? ===

 Yes. Indexing starts at 0. Thus new Fields( 3 ) would select the 4th item in a Tuple. You can also use relative positions. -1 would return the last, and -2 the second to last value in a Tuple. Field names and positions can be used together, new Fields( "name" , -1 ).

=== How do I create my own filter class? ===

 Your new filter must `extends c.o.Operation` and `implements c.o.Filter`. Your implementation must always declare the fields `Fields.ALL`. For example:
{{{
  public SomeFilter()
    {
    super( ANY, Fields.ALL );
    }
}}}

=== How do I create reusable assemblies? ===

 Subclass `c.p.PipeAssembly`. In the constructor assemble your reusable assembly using parameters passed in. Common parameters are the 'previous' pipe you are attaching to, or simply the 'name' of this assembly. Before your constructor returns, you must pass all the tail ends of your assembly to `setTails( Pipe... tails )`. This allows your `PipeAssembly` class to be attached to by subsequent assemblies. For example:
{{{
  public SomeAssembly( Pipe previous, Fields argumentFieldSelector, Fields fieldDeclaration )
    {
    // expects 3 argument values, should check argumentFieldSelector is the correct size
    // rename all fields for internal use
    Pipe pipe = new Each( previous, argumentFieldSelector, new Identity( new Fields( "n", "l", "v" ) ) );

    ...

    // rename fields to expected return values
    pipe = new Each( pipe, new Identity( fieldDeclaration ) );

    setTails( pipe );
    }
}}}


=== How do I print my tuple stream for debugging? ===

 Use the c.o.Debug filter. By default it will print your tuple stream to stderr. 

=== Can I enable DEBUG logging without updating every log4j.properties file in my cluster? ===

  Yes. Set this property on your `JobConf`. 
{{{
jobConf.set("log4j.logger","logger1=LEVEL,logger2=LEVEL");
}}}

 Where logger1 could be `cascading` and LEVEL could be `DEBUG`. Note only the loggers in the task mappers or task reducers will be configured. 

== Not yet released, available via svn ==

=== None ===